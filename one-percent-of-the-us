<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>1% of the United States</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #1a1a1a;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    font-family: 'Roboto Mono', monospace;
    cursor: crosshair;
  }

  #container {
    position: relative;
    width: 100vw;
    height: 100vh;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    display: block;
  }

  #overlay-canvas {
    pointer-events: none;
  }

  .panel {
    position: absolute;
    top: 18px;
    font-size: 10px;
    line-height: 2;
    pointer-events: none;
    letter-spacing: 0.06em;
    color: rgba(255, 255, 255, 0.32);
    font-weight: 300;
    text-transform: lowercase;
  }

  #panel-tl { left: 18px; }
  #panel-tr { right: 18px; text-align: right; }

  #loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: rgba(255,255,255,0.2);
    font-family: 'Roboto Mono', monospace;
    font-size: 11px;
    letter-spacing: 0.1em;
    pointer-events: none;
  }
</style>
</head>
<body>
<div id="container">
  <canvas id="map-canvas"></canvas>
  <canvas id="overlay-canvas"></canvas>
  <div class="panel" id="panel-tl">
    <div id="tl-pixels">loading map…</div>
    <div id="tl-sqmi"></div>
    <div id="tl-r"></div>
  </div>
  <div class="panel" id="panel-tr">
    <div>pixels in circle</div>
    <div id="tr-px">—</div>
  </div>
  <div id="loading">loading geography…</div>
</div>

<!-- D3 for projecting US geography -->
<script src="https://cdn.jsdelivr.net/npm/d3-array@3/dist/d3-array.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-geo@3/dist/d3-geo.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>

<script>
// ─── Constants ────────────────────────────────────────────────────────────────
const US_SQMI = 3_796_742; // Continental US + Alaska sq miles

// ─── Canvas Setup ─────────────────────────────────────────────────────────────
const mapCanvas  = document.getElementById('map-canvas');
const overlayCanvas = document.getElementById('overlay-canvas');
const mapCtx     = mapCanvas.getContext('2d');
const overlayCtx = overlayCanvas.getContext('2d');

let W, H;

// Offscreen canvas for pixel hit-testing
let offCanvas, offCtx, usImageData;

// US shape data (filled once topoJSON loads)
let totalUSPixels = 0;
let sqMiPerPx     = 0;
let circleRadius  = 0;
let pathGenerator; // d3-geo path generator bound to mapCtx/offCtx

// The geographic features (GeoJSON)
let nationFeature; // continental US
let alaskaFeature; // Alaska separately

// ─── Mouse State ──────────────────────────────────────────────────────────────
let mouseX = -1, mouseY = -1;
let isOverUS = false;

// ─── Draw State ───────────────────────────────────────────────────────────────
let cachedCirclePx = 0;
let cachedRadius = 0;
let mouseMoved = false;
let frameN = 0;

// ─── Projection Setup ─────────────────────────────────────────────────────────
// states-albers-10m.json is pre-projected into 975×610 pixel space.
// We use geoIdentity() to handle the pre-projected coordinates.
const SOURCE_W = 975;
const SOURCE_H = 610;
const PAD = 48;

function makeProjection() {
  // Fit 975×610 source into canvas with padding, centered
  const s  = Math.min((W - PAD * 2) / SOURCE_W, (H - PAD * 2) / SOURCE_H);
  const tx = (W - SOURCE_W * s) / 2;
  const ty = (H - SOURCE_H * s) / 2;
  // geoIdentity applies a simple translate+scale transform
  return d3.geoIdentity().scale(s).translate([tx, ty]);
}

// ─── Drawing ──────────────────────────────────────────────────────────────────
function drawMap(ctx, fillColor, strokeColor) {
  ctx.clearRect(0, 0, W, H);
  if (!nationFeature) return;

  const proj = makeProjection();
  const gen  = d3.geoPath(proj, ctx);

  ctx.save();
  if (fillColor) {
    ctx.beginPath();
    gen(nationFeature);
    ctx.fillStyle = fillColor;
    ctx.fill();
  }
  if (strokeColor) {
    ctx.beginPath();
    gen(nationFeature);
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth   = 1.2;
    ctx.lineJoin    = 'round';
    ctx.stroke();
  }
  ctx.restore();
}

function renderMap() {
  drawMap(mapCtx, '#ffffff', 'rgba(255,255,255,0.55)');
}

// ─── Pixel Counting ───────────────────────────────────────────────────────────
function buildOffscreenAndCount() {
  offCanvas = document.createElement('canvas');
  offCanvas.width  = W;
  offCanvas.height = H;
  offCtx = offCanvas.getContext('2d');

  // Draw nation in solid red for easy alpha/color hit-testing
  drawMap(offCtx, '#ff0000', null);

  const img = offCtx.getImageData(0, 0, W, H);
  usImageData = img;

  let n = 0;
  for (let i = 0; i < img.data.length; i += 4) {
    if (img.data[i] > 100) n++; // red channel
  }

  totalUSPixels = n;
  sqMiPerPx     = US_SQMI / n;
  circleRadius  = Math.sqrt(0.01 * n / Math.PI);

  document.getElementById('tl-pixels').textContent =
    `${n.toLocaleString()} px interior`;
  document.getElementById('tl-sqmi').textContent =
    `${sqMiPerPx.toFixed(2)} sq mi / px`;
  document.getElementById('tl-r').textContent =
    `circle r = ${circleRadius.toFixed(1)} px`;
}

function pixelIsUS(x, y) {
  if (!usImageData) return false;
  const ix = Math.round(x), iy = Math.round(y);
  if (ix < 0 || iy < 0 || ix >= W || iy >= H) return false;
  return usImageData.data[(iy * W + ix) * 4] > 100;
}

// ─── Circle Pixel Sampling ────────────────────────────────────────────────────
// Count US-interior pixels inside a circle of radius R centered on (cx, cy).
function sampleCirclePx(cx, cy, R, step) {
  if (!usImageData || R < 1) return 0;
  const d = usImageData.data;
  const R2 = R * R;
  const x0 = Math.max(0, Math.floor(cx - R));
  const x1 = Math.min(W - 1, Math.ceil(cx + R));
  const y0 = Math.max(0, Math.floor(cy - R));
  const y1 = Math.min(H - 1, Math.ceil(cy + R));
  let count = 0;
  for (let y = y0; y <= y1; y += step) {
    for (let x = x0; x <= x1; x += step) {
      const dx = x - cx, dy = y - cy;
      if (dx * dx + dy * dy <= R2) {
        if (d[(y * W + x) * 4] > 100) count++;
      }
    }
  }
  return count * step * step;
}

// ─── Adjusted Radius ──────────────────────────────────────────────────────────
// Find the circle radius such that the intersection with the US map = 1% of
// total US pixels. Near edges the circle is larger than the base radius so
// that the visible (clipped) portion still represents exactly 1%.
function computeAdjustedRadius(cx, cy) {
  const target = 0.01 * totalUSPixels;
  let R = circleRadius;
  for (let i = 0; i < 5; i++) {
    const inside = sampleCirclePx(cx, cy, R, 3);
    if (inside <= 0) { R = Math.min(R * 2, circleRadius * 8); continue; }
    const ratio = target / inside;
    R = Math.min(circleRadius * 8, R * Math.sqrt(ratio));
    if (Math.abs(ratio - 1) < 0.015) break;
  }
  return R;
}

// ─── Animation Frame ──────────────────────────────────────────────────────────
let animStarted = false;

function startAnim() {
  if (!animStarted) {
    animStarted = true;
    requestAnimationFrame(frame);
  }
}

function frame() {
  requestAnimationFrame(frame);
  frameN++;

  overlayCtx.clearRect(0, 0, W, H);

  if (!isOverUS || mouseX < 0 || !circleRadius || !nationFeature) {
    document.getElementById('tr-px').textContent = '—';
    return;
  }

  // Recompute adjusted radius only when mouse moves (cached otherwise)
  if (mouseMoved) {
    cachedRadius = computeAdjustedRadius(mouseX, mouseY);
    cachedCirclePx = sampleCirclePx(mouseX, mouseY, cachedRadius, 2);
    mouseMoved = false;
  }

  const R = cachedRadius;

  // Clip drawing to US map shape, then fill a circle.
  // The visible intersection is the "water filling the bucket" shape.
  overlayCtx.save();
  const proj = makeProjection();
  const gen  = d3.geoPath(proj, overlayCtx);
  overlayCtx.beginPath();
  gen(nationFeature);
  overlayCtx.clip();

  overlayCtx.beginPath();
  overlayCtx.arc(mouseX, mouseY, R, 0, Math.PI * 2);
  overlayCtx.fillStyle   = 'rgba(128, 128, 128, 0.32)';
  overlayCtx.fill();
  overlayCtx.strokeStyle = 'rgba(190, 190, 190, 0.55)';
  overlayCtx.lineWidth   = 1.2;
  overlayCtx.stroke();

  overlayCtx.restore();

  document.getElementById('tr-px').textContent = cachedCirclePx.toLocaleString();
}

// ─── Mouse Events ─────────────────────────────────────────────────────────────
window.addEventListener('mousemove', e => {
  mouseX = e.clientX;
  mouseY = e.clientY;
  isOverUS = pixelIsUS(mouseX, mouseY);
  if (isOverUS) mouseMoved = true;
});

window.addEventListener('mouseleave', () => {
  isOverUS = false;
  mouseX   = -1;
  mouseY   = -1;
});

// ─── Resize ───────────────────────────────────────────────────────────────────
function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  mapCanvas.width     = W;
  mapCanvas.height    = H;
  overlayCanvas.width  = W;
  overlayCanvas.height = H;

  if (nationFeature) {
    renderMap();
    buildOffscreenAndCount();
  }
}

window.addEventListener('resize', resize);

// ─── Load Geography and Init ──────────────────────────────────────────────────
(async () => {
  try {
    resize(); // set dimensions before data loads

    // Fetch the US atlas (10m = simplified, 50m = more simplified)
    const topo = await fetch(
      'https://cdn.jsdelivr.net/npm/us-atlas@3/states-albers-10m.json'
    ).then(r => r.json());

    // Merge all states into one nation polygon via topojson.merge
    // This gives us the outline of the entire continental US + Alaska + Hawaii
    // (albers projection already positions them as insets)
    const states = topojson.feature(topo, topo.objects.states);

    // Filter to continental US + Alaska (exclude Hawaii: FIPS 15)
    // Continental US FIPS codes: 01-56 except 02 (Alaska) and 15 (Hawaii)
    // We include Alaska (02) in the main shape; exclude Hawaii (15)
    const withoutHawaii = {
      type: 'FeatureCollection',
      features: states.features.filter(f => f.id !== '15')
    };

    // Merge the filtered states into a single polygon
    const statesWithoutHawaii = {
      type: 'GeometryCollection',
      geometries: topo.objects.states.geometries.filter(g => g.id !== '15')
    };
    nationFeature = topojson.merge(topo, statesWithoutHawaii.geometries);

    // Hide loading message
    document.getElementById('loading').style.display = 'none';

    // Render and count
    renderMap();
    buildOffscreenAndCount();

    // Start animation
    startAnim();

  } catch (err) {
    document.getElementById('loading').textContent =
      'error loading map — check network';
    console.error(err);

    // Fallback: still start animation loop
    startAnim();
  }
})();
</script>
</body>
</html>
